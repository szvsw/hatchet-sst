// eslint-disable-next-line @typescript-eslint/triple-slash-reference
/// <reference path="./.sst/platform/config.d.ts" />

// TODO: drop eslint config from old nextjs boilerplate
// TODO: better password creation/DATABASE_URL etc secret creation (e.g. from env var, or autogenerated, or from sst secret)
// TODO: don't store secrets in task definition env vars. use secrets instead which get passed in via `ssm` arguments
// TODO: separate service for dashboard? would require a dependency on first service which runs setup-config becoming stable.
// TODO: is SERVER_URL working? seems so.
// TODO: modularize
// TODO: better way to configure things like memory, cpu, instance type, etc.
// TODO: service can be placed into private subnets if desired in the transform which deals with SGs to Broker, but then a NAT gateway is needed (I think) to pull the images from ghcr.io
// TODO: put migrate/setup-config in their own service which gets conditionally deployed to avoid redeployment error on tenant pkey?
// TODO: hatchet-worker in same vpc

export default $config({
  app(input) {
    return {
      name: "hatchet",
      removal: input?.stage === "production" ? "retain" : "remove",
      protect: ["production"].includes(input?.stage),
      home: "aws",
    };
  },
  async run() {

    const normalizeName = (name: string, separator: string = "-") => {
      return `${separator === "/" ? "/" : ""}${$app.name}${separator}${$app.stage}${separator}${name}`
    }

    // CONFIGURATION VARIABLES
    // TODO: extract to configs in one way or another
    const rootDomain = "mit-sdl.run"
    const dbInstanceType = "t4g.medium"
    const brokerInstanceType = "mq.t3.micro"
    const dbStorage = "20 GB"
    const taskDefinitionCpu = "4 vCPU"
    const taskDefinitionMemory = "20 GB"

    // SSM Parameters
    const databaseUsername = new aws.ssm.Parameter(normalizeName("DatabaseUsername", "/"), {
      type: "String",
      value: "hatchet",
    })
    const databasePassword = new aws.ssm.Parameter(normalizeName("DatabasePassword", "/"), {
      type: "SecureString",
      value: "hatchet-1234567890", // TODO: initialize or otherwise load from env var/sst secret
    })
    const brokerUsername = new aws.ssm.Parameter(normalizeName("BrokerUsername", "/"), {
      type: "String",
      value: "hatchet",
    })
    const brokerPassword = new aws.ssm.Parameter(normalizeName("BrokerPassword", "/"), {
      type: "SecureString",
      value: "hatchet-1234567890", // TODO: initialize or otherwise load from env var/sst secret
    })

    // VPC Configuration
    const vpc = new sst.aws.Vpc("Vpc");

    // DATABASE CONFIGURATION
    const postgres = new sst.aws.Postgres("Postgres", {
      vpc,
      password: databasePassword.value,
      username: databaseUsername.value,
      database: "hatchet",
      instance: dbInstanceType,
      storage: dbStorage,
    });
    // TODO: store in a secret and pass in via ssm
    const DATABASE_URL = $interpolate`postgres://${postgres.username}:${postgres.password}@${postgres.host}:${postgres.port}/${postgres.database}`;

    // BROKER CONFIGURATION
    // We need to create a security group for the broker to be in so that it can be accessed
    // by the engine's service.
    const brokerTargetSecurityGroup = new aws.ec2.SecurityGroup(
      normalizeName("BrokerTargetSecurityGroup"),
      {
        vpcId: vpc.id,
      }
    )
    // We need to create a security group for the engine to be in so that it can access the broker.
    const brokerSourceSecurityGroup = new aws.ec2.SecurityGroup(
      normalizeName("BrokerSourceSecurityGroup"),
      {
        vpcId: vpc.id,
      }
    )

    // We need to allow the engine to access the broker.
    new aws.vpc.SecurityGroupIngressRule(
      normalizeName("BrokerIngressRule"),
      {
        securityGroupId: brokerTargetSecurityGroup.id,
        fromPort: 5671,
        toPort: 5671,
        ipProtocol: "tcp",
        referencedSecurityGroupId: brokerSourceSecurityGroup.id,
      }
    )

    // We need to allow the engine to access the broker's API.
    new aws.vpc.SecurityGroupIngressRule(
      normalizeName("BrokerApiIngressRule"),
      {
        securityGroupId: brokerTargetSecurityGroup.id,
        fromPort: 15671,
        toPort: 15671,
        ipProtocol: "tcp",
        referencedSecurityGroupId: brokerSourceSecurityGroup.id,
      }
    )

    const broker = new aws.mq.Broker(
      normalizeName("Broker"),
      {
        brokerName: normalizeName("Broker"),
        engineType: "RabbitMQ",
        engineVersion: "3.13",
        autoMinorVersionUpgrade: true,
        hostInstanceType: brokerInstanceType,
        publiclyAccessible: false,
        deploymentMode: "SINGLE_INSTANCE",
        logs: {
          general: true,
        },
        users: [{
          consoleAccess: true,
          username: brokerUsername.value,
          password: brokerPassword.value, // TODO: can this come from ssm?
        }],
        securityGroups: [brokerTargetSecurityGroup.id],
        subnetIds: [vpc.privateSubnets.apply((subnets) => subnets[0])],
      }
    );

    const brokerUrlWithoutProtocol = broker.instances[0].endpoints[0].apply((endpoint) => {
      return endpoint.split("://")[1]
    })

    // TODO: username and password are not resolving from broker output, so using a common ancestor (ssm)
    // TODO: store in a secret and pass in via ssm
    const SERVER_TASKQUEUE_RABBITMQ_URL = $interpolate`amqps://${brokerUsername.value}:${brokerPassword.value}@${brokerUrlWithoutProtocol}`


    // Engine Configuration
    const efs = new sst.aws.Efs("Efs", {
      vpc,
    });
    const cluster = new sst.aws.Cluster("Cluster", {
      vpc,
    });

    // const _serverLimitsDefaultWorkflowRunLimit = 1000000
    // const _serverLimitsDefaultWorkflowRunAlarmLimit = 7500000
    // const _serverLimitsDefaultWorkerLimit = 5000
    // const _serverLimitsDefaultWorkerAlarmLimit = 7500
    // const _serverLimitsDefaultTaskRunLimit = 1000000
    // const _serverLimitsDefaultTaskRunAlarmLimit = 7500000
    // const _serverLimitsDefaultWorkerSlotLimit = _serverLimitsDefaultWorkerLimit * 100
    // const _serverLimitsDefaultWorkerSlotAlarmLimit = _serverLimitsDefaultWorkerAlarmLimit * 100


    const ADMIN_EMAIL = `hatchet@${rootDomain}`
    const ADMIN_PASSWORD = "Hatchet1234567890"
    const ADMIN_NAME = "hatchet"

    const DEFAULT_TENANT_NAME = "Self-Hosted"
    const DEFAULT_TENANT_SLUG = "self-hosted"
    const DEFAULT_TENANT_ID = "77a6330d-40e4-4af1-b9e2-b3f713df9250"

    // TODO: if no domain is provided, make sure setup still works.
    const domain = `hatchet-${$app.stage}.${rootDomain}`

    const hatchetSetupEnvironment = {
      // Confirmed Correct
      DATABASE_URL, // Aurora PG
      SERVER_TASKQUEUE_RABBITMQ_URL, // Amazon MQ RabbitMQ
      SERVER_AUTH_COOKIE_DOMAIN: domain,
      SERVER_DEFAULT_ENGINE_VERSION: "V1",

      // Seems correct, but have questions
      // Currently, loadbalancer routes
      // - https/443 -> dashboard:80
      // - http/80 -> dashboard:80
      // - https/8443 -> engine:7070
      SERVER_URL: `https://${domain}`,
      SERVER_GRPC_BIND_ADDRESS: "0.0.0.0", // When would you ever change this?
      SERVER_GRPC_BROADCAST_ADDRESS: `${domain}:8443`, // Can a worker in same vpc bypass this to avoid going thru LB, and just use `engine:7070`?
      SERVER_INTERNAL_CLIENT_INTERNAL_GRPC_BROADCAST_ADDRESS: "engine:7070", // I think service connect is set up and working, but not positive? How would I know if it's working?

      // correct, but should be changed in production
      SERVER_AUTH_COOKIE_INSECURE: "t",
      SERVER_GRPC_INSECURE: "t", // Since loadbalancer is using https, can we remove? if so, would this cause problems for workers in the same network not going through LB?
      SERVER_AUTH_SET_EMAIL_VERIFIED: "t",

      // Tenant / Admin
      ADMIN_EMAIL,
      ADMIN_PASSWORD,
      ADMIN_NAME,
      DEFAULT_TENANT_NAME,
      DEFAULT_TENANT_SLUG,
      DEFAULT_TENANT_ID,
    }

    new sst.aws.Service(
      "Engine",
      {
        cluster,
        cpu: taskDefinitionCpu,
        memory: taskDefinitionMemory,
        // scaling: {
        //   min: 0,
        //   max: 0,
        // },
        loadBalancer: {
          domain,
          rules: [
            {
              listen: "80/http",
              container: "dashboard",
              forward: "80/http",
            },
            {
              listen: "443/https",
              container: "dashboard",
              forward: "80/http",
            },
            {
              listen: "8443/https", // Must be HTTPS in order for healthcheck.protocolVersion = "GRPC" to work
              container: "engine",
              forward: "7070/http",
            },
          ],
        },
        containers: [
          // SIDECARS FIRST
          // TRANSFORM takes care of
          // - inter-container dependencies
          // - adding service to security group so it can access broker
          // - setting healthcheck.protocolVersion = "GRPC" for engine service
          // MIGRATION
          {
            name: "migration",
            image: "ghcr.io/hatchet-dev/hatchet/hatchet-migrate:latest",
            command: ["/hatchet/hatchet-migrate"],
            environment: {
              DATABASE_URL,
            }
          },
          // SETUP CONFIG
          {
            name: "setup-config",
            image: "ghcr.io/hatchet-dev/hatchet/hatchet-admin:latest",
            command: ["/hatchet/hatchet-admin", "quickstart", "--skip", "certs", "--generated-config-dir", "/mnt/efs/config", "--overwrite=false"],
            environment: hatchetSetupEnvironment,
            volumes: [
              {
                path: "/mnt/efs",
                efs,
              }
            ]
          },
          // ENGINE
          {
            name: "engine",
            image: "ghcr.io/hatchet-dev/hatchet/hatchet-engine:latest",
            command: ["/hatchet/hatchet-engine", "--config", "/mnt/efs/config"],
            environment: {
              DATABASE_URL,
              SERVER_GRPC_BIND_ADDRESS: "0.0.0.0",
              SERVER_AUTH_SET_EMAIL_VERIFIED: "t",
              SERVER_GRPC_INSECURE: "t",
            },
            volumes: [
              {
                path: "/mnt/efs",
                efs,
              }
            ]
          },
          // DASHBOARD
          // TODO: separate service?
          {
            name: "dashboard",
            image: "ghcr.io/hatchet-dev/hatchet/hatchet-dashboard:latest",
            command: ["sh", "./entrypoint.sh", "--config", "/mnt/efs/config"],
            environment: {
              DATABASE_URL,
            },
            volumes: [
              {
                path: "/mnt/efs",
                efs,
              }
            ]
          }
        ],
        link: [efs, postgres, broker],
        transform: {
          target(args) {
            if (args.port === 7070) {
              args.protocolVersion = "GRPC"
              args.protocol = "HTTP"
            }
          },
          taskDefinition: (args) => {
            const defs = $jsonParse(args.containerDefinitions)
            defs.apply((defs) => {
              defs.forEach((def) => {
                if (["engine", "dashboard"].includes(def.name)) {
                  def.dependsOn = [
                    {
                      containerName: "migration",
                      condition: "SUCCESS",
                    },
                    // {
                    //   containerName: "setup-config",
                    //   condition: "SUCCESS",
                    // }
                  ]
                }
                if (["migration", "setup-config"].includes(def.name)) {
                  def.essential = false
                }
              })
            })
            args.containerDefinitions = $jsonStringify(defs)
          },
          service(args) {
            if (args.networkConfiguration) {
              const securityGroups = vpc.securityGroups.apply((groups) => [...groups, brokerSourceSecurityGroup.id])
              args.networkConfiguration = {
                ...args.networkConfiguration,
                securityGroups,
              }
            }
          }
        }
      },
    )
  },
});
