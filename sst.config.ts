// eslint-disable-next-line @typescript-eslint/triple-slash-reference
/// <reference path="./.sst/platform/config.d.ts" />

export default $config({
  app(input) {
    return {
      name: "hatchet",
      removal: input?.stage === "production" ? "retain" : "remove",
      protect: ["production"].includes(input?.stage),
      home: "aws",
    };
  },
  async run() {
    // TODO: better password creation/DATABASE_URL etc secret creation (e.g. from env var autogenerated, or from sst secret)
    // TODO: don't store secrets in task definition env vars. use secrets instead.
    // TODO: health checks
    // TODO: separate service for dashboard?
    // TODO: better way to configure things like memory, cpu, instance type, etc.
    // TODO: hatchet-worker
    // TODO: get all url references working
    // TODO: is SERVER_URL working
    // TODO: modularize

    // WIP
    // TODO: better scoping of broker ingress rules (i.e. only for specific services, rather than whole cluster)
    // TODO: because we are setting vpc security group on cluster directly for security group purposes, we end up needing to set `isSstVpc: true` on the cluster.
    // since that only gets set when passing in the component (rather than an object)

    // DONE
    // TODO: normalize names of non-sst resources using $app.name-$app.stage-(component-name)

    const normalizeName = (name: string) => {
      return `${$app.name}-${$app.stage}-${name}`
    }

    const databasePassword = new aws.ssm.Parameter("DatabasePassword", {
      type: "SecureString",
      value: "hatchet-1234567890",
    })
    const brokerPassword = new aws.ssm.Parameter("BrokerPassword", {
      type: "SecureString",
      value: "hatchet-1234567890",
    })

    const vpc = new sst.aws.Vpc("Vpc");
    const efs = new sst.aws.Efs("Efs", {
      vpc,
    });

    const postgres = new sst.aws.Postgres("Postgres", {
      vpc,
      password: databasePassword.value,
      username: "hatchet",
      database: "hatchet",
    });
    const DATABASE_URL = $interpolate`postgres://${postgres.username}:${postgres.password}@${postgres.host}:${postgres.port}/${postgres.database}`;
    // const databaseConnStringSecret = new aws.ssm.Parameter("HatchetDatabaseUrl", {
    //   type: "SecureString",
    //   value: databaseConnString,
    // })
    // const DATABASE_URL = databaseConnStringSecret.value

    const brokerTargetSecurityGroup = new aws.ec2.SecurityGroup(
      normalizeName("BrokerTargetSecurityGroup"),
      {
        vpcId: vpc.id,
      }
    )
    const brokerSourceSecurityGroup = new aws.ec2.SecurityGroup(
      normalizeName("BrokerSourceSecurityGroup"),
      {
        vpcId: vpc.id,
      }
    )

    new aws.vpc.SecurityGroupIngressRule(
      normalizeName("BrokerIngressRule"),
      {
        securityGroupId: brokerTargetSecurityGroup.id,
        fromPort: 5671,
        toPort: 5671,
        ipProtocol: "tcp",
        referencedSecurityGroupId: brokerSourceSecurityGroup.id,
      }
    )

    new aws.vpc.SecurityGroupIngressRule(
      normalizeName("BrokerApiIngressRule"),
      {
        securityGroupId: brokerTargetSecurityGroup.id,
        fromPort: 15671,
        toPort: 15671,
        ipProtocol: "tcp",
        referencedSecurityGroupId: brokerSourceSecurityGroup.id,
      }
    )

    const broker = new aws.mq.Broker(
      normalizeName("Broker"),
      {
        brokerName: normalizeName("Broker"),
        engineType: "RabbitMQ",
        engineVersion: "3.13",
        autoMinorVersionUpgrade: true,
        hostInstanceType: "mq.t3.micro",
        publiclyAccessible: false,
        deploymentMode: "SINGLE_INSTANCE",
        logs: {
          general: true,
        },
        users: [{
          consoleAccess: true,
          username: "hatchet",
          password: brokerPassword.value,
        }],
        securityGroups: [brokerTargetSecurityGroup.id],
        subnetIds: [vpc.privateSubnets.apply((subnets) => subnets[0])],
      }
    );

    const brokerUrlWithoutProtocol = broker.instances[0].endpoints[0].apply((endpoint) => {
      return endpoint.split("://")[1]
    })

    // TODO: username and password are not resolving.
    const SERVER_TASKQUEUE_RABBITMQ_URL = $interpolate`amqps://hatchet:${brokerPassword.value}@${brokerUrlWithoutProtocol}`


    const cluster = new sst.aws.Cluster("Cluster", {
      vpc,
      // vpc: {
      //   id: vpc.id,
      //   containerSubnets: vpc.publicSubnets,
      //   loadBalancerSubnets: vpc.publicSubnets,
      //   cloudmapNamespaceId: vpc.nodes.cloudmapNamespace.id,
      //   cloudmapNamespaceName: vpc.nodes.cloudmapNamespace.name,
      //   securityGroups: vpc.securityGroups.apply((groups) => [...groups, brokerSourceSecurityGroup.id]),
      //   isSstVpc: true,
      // },
    });

    const rootDomain = "mit-sdl.run"
    const domain = `hatchet-${$app.stage}.${rootDomain}`

    new sst.aws.Service(
      "Engine",
      {
        cluster,
        cpu: "4 vCPU",
        memory: "24 GB",

        loadBalancer: {
          domain,
          rules: [
            {
              listen: "80/http",
              container: "dashboard",
              forward: "80/http",
            },
            {
              listen: "443/https",
              container: "dashboard",
              forward: "80/http",
            },
            {
              listen: "7070/http",
              container: "engine",
              forward: "7070/http",
            },
          ],
        },
        containers: [
          // SIDECARS FIRST
          // TRANSFORM takes care of inter-container dependencies
          // MIGRATION
          {
            name: "migration",
            image: "ghcr.io/hatchet-dev/hatchet/hatchet-migrate:latest",
            command: ["/hatchet/hatchet-migrate"],
            environment: {
              DATABASE_URL,
            }
          },
          // SETUP CONFIG
          {
            name: "setup-config",
            image: "ghcr.io/hatchet-dev/hatchet/hatchet-admin:latest",
            command: ["/hatchet/hatchet-admin", "quickstart", "--skip", "certs", "--generated-config-dir", "/mnt/efs/config", "--overwrite=true"],
            environment: {
              // Needed?
              // SERVER_URL

              // WIP
              SERVER_AUTH_COOKIE_DOMAIN: domain,

              // MAYBE
              DATABASE_URL,
              SERVER_TASKQUEUE_RABBITMQ_URL,
              SERVER_GRPC_BROADCAST_ADDRESS: "engine:7070", // or does this need to be external?

              // GOOD
              SERVER_AUTH_COOKIE_INSECURE: "t",
              SERVER_GRPC_BIND_ADDRESS: "0.0.0.0",
              SERVER_GRPC_INSECURE: "t",
              SERVER_DEFAULT_ENGINE_VERSION: "V1",
              SERVER_INTERNAL_CLIENT_INTERNAL_GRPC_BROADCAST_ADDRESS: "engine:7070", // TODO: Is this necessary?
              SERVER_AUTH_SET_EMAIL_VERIFIED: "t",
            },
            volumes: [
              {
                path: "/mnt/efs",
                efs,
              }
            ]
          },
          // ENGINE
          {
            name: "engine",
            image: "ghcr.io/hatchet-dev/hatchet/hatchet-engine:latest",
            command: ["/hatchet/hatchet-engine", "--config", "/mnt/efs/config"],
            environment: {
              DATABASE_URL,
              SERVER_GRPC_BIND_ADDRESS: "0.0.0.0",
              SERVER_AUTH_SET_EMAIL_VERIFIED: "t",
              SERVER_GRPC_INSECURE: "t",
            },
            volumes: [
              {
                path: "/mnt/efs",
                efs,
              }
            ]
          },
          // DASHBOARD
          // TODO: separate service?
          {
            name: "dashboard",
            image: "ghcr.io/hatchet-dev/hatchet/hatchet-dashboard:latest",
            command: ["sh", "./entrypoint.sh", "--config", "/mnt/efs/config"],
            environment: {
              DATABASE_URL,
            },
            volumes: [
              {
                path: "/mnt/efs",
                efs,
              }
            ]
          }
        ],
        link: [efs, postgres, broker],
        transform: {
          taskDefinition: (args) => {
            const defs = $jsonParse(args.containerDefinitions)
            defs.apply((defs) => {
              defs.forEach((def) => {
                if (["engine", "dashboard"].includes(def.name)) {
                  def.dependsOn = [
                    {
                      containerName: "migration",
                      condition: "SUCCESS",
                    },
                    {
                      containerName: "setup-config",
                      condition: "SUCCESS",
                    }
                  ]
                }
                if (["migration", "setup-config"].includes(def.name)) {
                  def.essential = false
                }
              })
            })
            args.containerDefinitions = $jsonStringify(defs)
          },
          service(args) {
            if (args.networkConfiguration) {
              const subnets = vpc.securityGroups.apply((groups) => [...groups, brokerSourceSecurityGroup.id])
              args.networkConfiguration = {
                ...args.networkConfiguration,
                subnets,
              }
            }
          }
        }
      },
    )
  },
});
